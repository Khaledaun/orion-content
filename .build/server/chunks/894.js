"use strict";exports.id=894,exports.ids=[894],exports.modules={36783:(e,t,r)=>{r.d(t,{iO:()=>i});let s=[/\b[A-Za-z0-9]{20,}\b/g,/sk-[A-Za-z0-9]{48}/g,/pk_[A-Za-z0-9]{24}/g,/Bearer\s+[A-Za-z0-9\-._~+/]+=*/gi,/postgresql:\/\/[^@]+@[^\/]+\/[^\s]+/gi,/mysql:\/\/[^@]+@[^\/]+\/[^\s]+/gi,/mongodb:\/\/[^@]+@[^\/]+\/[^\s]+/gi,/\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/g,/password["\s]*[:=]["\s]*[^"\s,}]+/gi,/secret["\s]*[:=]["\s]*[^"\s,}]+/gi,/key["\s]*[:=]["\s]*[^"\s,}]+/gi,/\b\d{4}[\s-]?\d{4}[\s-]?\d{4}[\s-]?\d{4}\b/g,/\b\d{3}-\d{2}-\d{4}\b/g,/\b\d{3}[-.]?\d{3}[-.]?\d{4}\b/g],a=["password","secret","key","token","auth","credential","private","confidential","sensitive","valueEnc","dataEnc"];function n(e){let t=e;for(let e of s)t=t.replace(e,e=>e.length<=4?"*".repeat(e.length):e.substring(0,2)+"*".repeat(e.length-4)+e.substring(e.length-2));return t}function i(e){try{return function e(t){if(null==t)return t;if("string"==typeof t)return n(t);if("number"==typeof t||"boolean"==typeof t)return t;if(Array.isArray(t))return t.map(t=>e(t));if("object"==typeof t){let r={};for(let[s,i]of Object.entries(t)){let t=s.toLowerCase();a.some(e=>t.includes(e))&&"string"==typeof i?r[s]=n(i):r[s]=e(i)}return r}return t}(e)}catch(e){return"[REDACTED - Error during redaction]"}}},5894:(e,t,r)=>{r.d(t,{jl:()=>m,kT:()=>A,ir:()=>h,UR:()=>y,hC:()=>C,Io:()=>E});var s=r(87070),a=r(53524),n=r(84770);function i(){let e=process.env.ENCRYPTION_KEY;if(!e)throw Error("ENCRYPTION_KEY environment variable is required");return Buffer.from(e,"base64")}function o(e){let t=i(),r=(0,n.randomBytes)(12),s=(0,n.createCipheriv)("aes-256-gcm",t,r);s.setAAD(Buffer.from("orion-cms-credentials"));let a=s.update(e,"utf8","base64");a+=s.final("base64");let o=s.getAuthTag(),c={iv:r.toString("base64"),tag:o.toString("base64"),data:a};return Buffer.from(JSON.stringify(c)).toString("base64")}class c{constructor(e){this.prisma=e}async createCredential(e){let{value:t,...r}=e;if(await this.prisma.credential.findUnique({where:{key:e.key}}))throw Error(`Credential with key '${e.key}' already exists`);let s=o(t);return await this.prisma.credential.create({data:{...r,valueEnc:s},select:{id:!0,name:!0,key:!0,description:!0,isActive:!0,createdAt:!0,updatedAt:!0}})}async getAllCredentials(){return this.prisma.credential.findMany({select:{id:!0,name:!0,key:!0,description:!0,isActive:!0,createdAt:!0,updatedAt:!0},orderBy:{createdAt:"desc"}})}async getCredentialById(e){let t=await this.prisma.credential.findUnique({where:{id:e},select:{id:!0,name:!0,key:!0,description:!0,isActive:!0,createdAt:!0,updatedAt:!0}});if(!t)throw Error("Credential not found");return t}async getCredentialValue(e){let t=await this.prisma.credential.findUnique({where:{key:e,isActive:!0},select:{valueEnc:!0}});if(!t)return null;try{return function(e){let t=i();try{let r=JSON.parse(Buffer.from(e,"base64").toString()),s=Buffer.from(r.iv,"base64"),a=Buffer.from(r.tag,"base64"),i=r.data,o=(0,n.createDecipheriv)("aes-256-gcm",t,s);o.setAAD(Buffer.from("orion-cms-credentials")),o.setAuthTag(a);let c=o.update(i,"base64","utf8");return c+=o.final("utf8")}catch(e){throw Error("Failed to decrypt credential data")}}(t.valueEnc)}catch(t){return console.error(`Failed to decrypt credential '${e}':`,t),null}}async updateCredential(e,t){let{value:r,...s}=t,a=await this.prisma.credential.findUnique({where:{id:e}});if(!a)throw Error("Credential not found");if(t.key&&t.key!==a.key&&await this.prisma.credential.findUnique({where:{key:t.key}}))throw Error(`Credential with key '${t.key}' already exists`);let n={...s};return r&&(n.valueEnc=o(r)),await this.prisma.credential.update({where:{id:e},data:n,select:{id:!0,name:!0,key:!0,description:!0,isActive:!0,createdAt:!0,updatedAt:!0}})}async deleteCredential(e){if(!await this.prisma.credential.findUnique({where:{id:e}}))throw Error("Credential not found");return await this.prisma.credential.delete({where:{id:e}}),{success:!0}}async testCredential(e,t){let r=await this.getCredentialValue(e);if(!r)return{success:!1,message:"Credential not found or inactive"};if(r.length<10)return{success:!1,message:"Credential value appears to be too short"};if(t)try{let e=await fetch(t,{headers:{Authorization:`Bearer ${r}`,"Content-Type":"application/json"}});if(e.ok)return{success:!0,message:"Credential test successful"};return{success:!1,message:`Test failed with status: ${e.status}`}}catch(e){return{success:!1,message:`Test failed: ${e instanceof Error?e.message:"Unknown error"}`}}return{success:!0,message:"Credential format appears valid"}}}var l=r(7410);let d=l.z.object({name:l.z.string().min(1,"Name is required").max(100,"Name too long"),key:l.z.string().min(1,"Key is required").max(100,"Key too long"),value:l.z.string().min(1,"Value is required"),description:l.z.string().optional(),isActive:l.z.boolean().default(!0)}),u=l.z.object({name:l.z.string().min(1,"Name is required").max(100,"Name too long").optional(),key:l.z.string().min(1,"Key is required").max(100,"Key too long").optional(),value:l.z.string().min(1,"Value is required").optional(),description:l.z.string().optional(),isActive:l.z.boolean().optional()}),f=l.z.object({key:l.z.string().min(1,"Key is required"),testEndpoint:l.z.string().url("Must be a valid URL").optional()});l.z.object({id:l.z.string(),name:l.z.string(),key:l.z.string(),description:l.z.string().nullable(),isActive:l.z.boolean(),createdAt:l.z.date(),updatedAt:l.z.date()});var g=r(36783);let p=new c(new a.PrismaClient);async function y(e){try{let e=await p.getAllCredentials();return console.log(`[CREDENTIALS] Listed ${e.length} credentials`),s.NextResponse.json({success:!0,data:e})}catch(e){return console.error("[CREDENTIALS] Error listing credentials:",(0,g.iO)(e)),s.NextResponse.json({success:!1,error:"Failed to list credentials"},{status:500})}}async function m(e){try{let t=await e.json(),r=d.parse(t),a=await p.createCredential(r);return console.log(`[CREDENTIALS] Created credential: ${a.name} (${a.key})`),s.NextResponse.json({success:!0,data:a},{status:201})}catch(r){console.error("[CREDENTIALS] Error creating credential:",(0,g.iO)(r));let e=r instanceof Error?r.message:"Failed to create credential",t=e.includes("already exists")?409:500;return s.NextResponse.json({success:!1,error:e},{status:t})}}async function h(e,{params:t}){try{let e=await p.getCredentialById(t.id);return s.NextResponse.json({success:!0,data:e})}catch(r){console.error(`[CREDENTIALS] Error getting credential ${t.id}:`,(0,g.iO)(r));let e=r instanceof Error?r.message:"Failed to get credential";return s.NextResponse.json({success:!1,error:e},{status:"Credential not found"===e?404:500})}}async function E(e,{params:t}){try{let r=await e.json(),a=u.parse(r),n=await p.updateCredential(t.id,a);return console.log(`[CREDENTIALS] Updated credential: ${n.name} (${n.key})`),s.NextResponse.json({success:!0,data:n})}catch(a){console.error(`[CREDENTIALS] Error updating credential ${t.id}:`,(0,g.iO)(a));let e=a instanceof Error?a.message:"Failed to update credential",r="Credential not found"===e?404:e.includes("already exists")?409:500;return s.NextResponse.json({success:!1,error:e},{status:r})}}async function A(e,{params:t}){try{return await p.deleteCredential(t.id),console.log(`[CREDENTIALS] Deleted credential: ${t.id}`),s.NextResponse.json({success:!0,message:"Credential deleted successfully"})}catch(r){console.error(`[CREDENTIALS] Error deleting credential ${t.id}:`,(0,g.iO)(r));let e=r instanceof Error?r.message:"Failed to delete credential";return s.NextResponse.json({success:!1,error:e},{status:"Credential not found"===e?404:500})}}async function C(e){try{let t=await e.json(),r=f.parse(t),a=await p.testCredential(r.key,r.testEndpoint);return console.log(`[CREDENTIALS] Tested credential: ${r.key} - ${a.success?"SUCCESS":"FAILED"}`),s.NextResponse.json({success:!0,data:a})}catch(e){return console.error("[CREDENTIALS] Error testing credential:",(0,g.iO)(e)),s.NextResponse.json({success:!1,error:"Failed to test credential"},{status:500})}}}};