import crypto from 'crypto'

const SECRET = process.env.NEXTAUTH_SECRET || ''
if (!SECRET) console.warn('WARNING: NEXTAUTH_SECRET is empty; crypto will use a weak key')
const KEY = crypto.createHash('sha256').update(SECRET).digest() // 32 bytes

export function encryptJson(data: unknown): string {
  const iv = crypto.randomBytes(12) // GCM IV = 12 bytes
  const cipher = crypto.createCipheriv('aes-256-gcm', KEY, iv)
  const pt = Buffer.from(JSON.stringify(data), 'utf8')
  const ct = Buffer.concat([cipher.update(pt), cipher.final()])
  const tag = cipher.getAuthTag()

  // wrap in base64 JSON so itâ€™s safe to store as text
  const payload = {
    v: 1,
    alg: 'aes-256-gcm',
    iv: iv.toString('base64'),
    tag: tag.toString('base64'),
    ct: ct.toString('base64'),
  }
  return Buffer.from(JSON.stringify(payload), 'utf8').toString('base64')
}

export function decryptJson(enc: string): any {
  try {
    // expect our base64-wrapped JSON
    const raw = Buffer.from(enc, 'base64').toString('utf8')
    const obj = JSON.parse(raw)
    if (obj && obj.alg === 'aes-256-gcm' && obj.v === 1) {
      const iv = Buffer.from(obj.iv, 'base64')
      const tag = Buffer.from(obj.tag, 'base64')
      const ct = Buffer.from(obj.ct, 'base64')
      const decipher = crypto.createDecipheriv('aes-256-gcm', KEY, iv)
      decipher.setAuthTag(tag)
      const pt = Buffer.concat([decipher.update(ct), decipher.final()])
      return JSON.parse(pt.toString('utf8'))
    }
    // fallback: maybe base64 contained plain JSON
    return JSON.parse(raw)
  } catch {
    // final fallback: maybe DB holds plain JSON (no base64)
    try { return JSON.parse(enc) } catch { throw new Error('decryptJson failed') }
  }
}
