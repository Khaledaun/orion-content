import crypto from 'node:crypto';

// Derive a 32-byte key from NEXTAUTH_SECRET (or any long secret you prefer)
const SECRET = process.env.NEXTAUTH_SECRET || 'dev-secret-change-me';
const KEY = crypto.createHash('sha256').update(SECRET).digest(); // 32 bytes
const ALGO = 'aes-256-gcm';

// Compact JSON serializer (keeps output small but still structured)
function stringify(obj: unknown): string {
  return JSON.stringify(obj);
}
function parseJSON(s: string): any {
  return JSON.parse(s);
}

/**
 * Encrypt any JSON-serializable value with AES-256-GCM.
 * Returns a JSON string: {"v":1,"iv":"...","tag":"...","data":"..."} (all base64).
 */
export function encryptJson(data: unknown): string {
  const iv = crypto.randomBytes(12); // 96-bit nonce recommended for GCM
  const cipher = crypto.createCipheriv(ALGO, KEY, iv);

  const plaintext = Buffer.from(stringify(data), 'utf8');
  const ciphertext = Buffer.concat([cipher.update(plaintext), cipher.final()]);
  const tag = cipher.getAuthTag();

  return stringify({
    v: 1,
    iv: iv.toString('base64'),
    tag: tag.toString('base64'),
    data: ciphertext.toString('base64'),
  });
}

/**
 * Decrypt a string produced by encryptJson.
 * (Also supports a legacy base64 "v1:" packed format if ever encountered.)
 */
export function decryptJson(enc: string): any {
  // Try structured JSON format first
  try {
    const obj = parseJSON(enc);
    if (obj && obj.v === 1 && obj.iv && obj.tag && obj.data) {
      const iv = Buffer.from(obj.iv, 'base64');
      const tag = Buffer.from(obj.tag, 'base64');
      const ciphertext = Buffer.from(obj.data, 'base64');

      const decipher = crypto.createDecipheriv(ALGO, KEY, iv);
      decipher.setAuthTag(tag);

      const plaintext = Buffer.concat([decipher.update(ciphertext), decipher.final()]);
      return parseJSON(plaintext.toString('utf8'));
    }
  } catch {
    // fall through to legacy check
  }

  // Legacy packed base64 support (prefix "v1:" + iv(12) + tag(16) + data)
  try {
    if (enc.startsWith('v1:')) {
      const buf = Buffer.from(enc.slice(3), 'base64'); // drop "v1:"
      const iv = buf.subarray(0, 12);
      const tag = buf.subarray(12, 28);
      const data = buf.subarray(28);

      const decipher = crypto.createDecipheriv(ALGO, KEY, iv);
      decipher.setAuthTag(tag);

      const plaintext = Buffer.concat([decipher.update(data), decipher.final()]);
      return parseJSON(plaintext.toString('utf8'));
    }
  } catch {
    // ignore
  }

  throw new Error('Unsupported encrypted payload format');
}
