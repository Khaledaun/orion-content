// app/api/sites/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/prisma'
import { requireAuth } from '@/lib/auth'

export const runtime = 'nodejs'

// GET /api/sites  -> list sites
async function handleGET(_req: NextRequest) {
  const sites = await prisma.site.findMany({
    orderBy: { createdAt: 'desc' },
    include: {
      _count: { select: { categories: true, topics: true } },
    },
  })
  return NextResponse.json({ ok: true, sites })
}

// POST /api/sites -> create site
// Accepts either:
//   A) { key, name, baseUrl, ... }   -> uses key as slug
//   B) { name, slug, baseUrl }
async function handlePOST(req: NextRequest) {
  const body = await req.json().catch(() => ({} as any))

  const slug: string | undefined = body.slug ?? body.key
  const name: string | undefined = body.name
  const baseUrl: string | undefined = body.baseUrl

  if (!slug || !name || !baseUrl) {
    return NextResponse.json(
      { error: 'Missing required fields: slug/key, name, baseUrl' },
      { status: 400 }
    )
  }

  try {
    const site = await prisma.site.create({
      data: {
        // keep to commonly-present fields to avoid schema drift issues
        slug,
        name,
        baseUrl,
      } as any,
    })
    return NextResponse.json({ ok: true, site })
  } catch (error: unknown) {
    const code = (error as { code?: string })?.code
    const msg = (error as Error)?.message ?? String(error)
    if (code === 'P2002') {
      return NextResponse.json(
        { error: 'Site already exists', details: msg },
        { status: 409 }
      )
    }
    return NextResponse.json(
      { error: 'Failed to create site', details: msg },
      { status: 500 }
    )
  }
}

// Auth wrappers
export async function GET(req: NextRequest) {
  const unauth = await requireAuth(req)
  if (unauth) return unauth
  return handleGET(req)
}

export async function POST(req: NextRequest) {
  const unauth = await requireAuth(req)
  if (unauth) return unauth
  return handlePOST(req)
}
